<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AbstractInterfaceConfig.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">dubbo-all</a> &gt; <a href="../index.html" class="el_bundle">dubbo-config-api</a> &gt; <a href="index.source.html" class="el_package">org.apache.dubbo.config</a> &gt; <span class="el_source">AbstractInterfaceConfig.java</span></div><h1>AbstractInterfaceConfig.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.dubbo.config;

import org.apache.dubbo.common.Constants;
import org.apache.dubbo.common.URL;
import org.apache.dubbo.common.URLBuilder;
import org.apache.dubbo.common.Version;
import org.apache.dubbo.common.config.Environment;
import org.apache.dubbo.common.extension.ExtensionLoader;
import org.apache.dubbo.common.utils.Assert;
import org.apache.dubbo.common.utils.CollectionUtils;
import org.apache.dubbo.common.utils.ConfigUtils;
import org.apache.dubbo.common.utils.NetUtils;
import org.apache.dubbo.common.utils.ReflectUtils;
import org.apache.dubbo.common.utils.StringUtils;
import org.apache.dubbo.common.utils.UrlUtils;
import org.apache.dubbo.config.context.ConfigManager;
import org.apache.dubbo.config.support.Parameter;
import org.apache.dubbo.configcenter.DynamicConfiguration;
import org.apache.dubbo.configcenter.DynamicConfigurationFactory;
import org.apache.dubbo.metadata.integration.MetadataReportService;
import org.apache.dubbo.monitor.MonitorFactory;
import org.apache.dubbo.monitor.MonitorService;
import org.apache.dubbo.registry.RegistryService;
import org.apache.dubbo.rpc.Filter;
import org.apache.dubbo.rpc.InvokerListener;
import org.apache.dubbo.rpc.ProxyFactory;
import org.apache.dubbo.rpc.cluster.Cluster;
import org.apache.dubbo.rpc.model.ApplicationModel;
import org.apache.dubbo.rpc.support.MockInvoker;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static org.apache.dubbo.common.config.ConfigurationUtils.parseProperties;
import static org.apache.dubbo.common.extension.ExtensionLoader.getExtensionLoader;

/**
 * AbstractDefaultConfig
 *
 * @export
 */
<span class="nc" id="L64">public abstract class AbstractInterfaceConfig extends AbstractMethodConfig {</span>

    private static final long serialVersionUID = -1559314110797223229L;

    /**
     * Local impl class name for the service interface
     */
    protected String local;

    /**
     * Local stub class name for the service interface
     */
    protected String stub;

    /**
     * Service monitor
     */
    protected MonitorConfig monitor;

    /**
     * Strategies for generating dynamic agentsï¼Œthere are two strategies can be choosed: jdk and javassist
     */
    protected String proxy;

    /**
     * Cluster type
     */
    protected String cluster;

    /**
     * The {@link Filter} when the provider side exposed a service or the customer side references a remote service used,
     * if there are more than one, you can use commas to separate them
     */
    protected String filter;

    /**
     * The Listener when the provider side exposes a service or the customer side references a remote service used
     * if there are more than one, you can use commas to separate them
     */
    protected String listener;

    /**
     * The owner of the service providers
     */
    protected String owner;

    /**
     * Connection limits, 0 means shared connection, otherwise it defines the connections delegated to the current service
     */
    protected Integer connections;

    /**
     * The layer of service providers
     */
    protected String layer;

    /**
     * The application info
     */
    protected ApplicationConfig application;

    /**
     * The module info
     */
    protected ModuleConfig module;

    /**
     * Registry centers
     */
    protected List&lt;RegistryConfig&gt; registries;

    protected String registryIds;

    // connection events
    protected String onconnect;

    /**
     * Disconnection events
     */
    protected String ondisconnect;

    /**
     * The metrics configuration
     */
    protected MetricsConfig metrics;
    protected MetadataReportConfig metadataReportConfig;

    protected ConfigCenterConfig configCenter;

    // callback limits
    private Integer callbacks;
    // the scope for referring/exporting a service, if it's local, it means searching in current JVM only.
    private String scope;

    protected String tag;

    /**
     * Check whether the registry config is exists, and then conversion it to {@link RegistryConfig}
     */
    protected void checkRegistry() {
<span class="nc" id="L164">        loadRegistriesFromBackwardConfig();</span>

<span class="nc" id="L166">        convertRegistryIdsToRegistries();</span>

<span class="nc bnc" id="L168" title="All 2 branches missed.">        for (RegistryConfig registryConfig : registries) {</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">            if (!registryConfig.isValid()) {</span>
<span class="nc" id="L170">                throw new IllegalStateException(&quot;No registry config found or it's not a valid config! &quot; +</span>
                        &quot;The registry config is: &quot; + registryConfig);
            }
<span class="nc" id="L173">        }</span>

<span class="nc" id="L175">        useRegistryForConfigIfNecessary();</span>
<span class="nc" id="L176">    }</span>

    @SuppressWarnings(&quot;deprecation&quot;)
    protected void checkApplication() {
        // for backward compatibility
<span class="nc" id="L181">        createApplicationIfAbsent();</span>

<span class="nc bnc" id="L183" title="All 2 branches missed.">        if (!application.isValid()) {</span>
<span class="nc" id="L184">            throw new IllegalStateException(&quot;No application config found or it's not a valid config! &quot; +</span>
                    &quot;Please add &lt;dubbo:application name=\&quot;...\&quot; /&gt; to your spring config.&quot;);
        }

<span class="nc" id="L188">        ApplicationModel.setApplication(application.getName());</span>

        // backward compatibility
<span class="nc" id="L191">        String wait = ConfigUtils.getProperty(Constants.SHUTDOWN_WAIT_KEY);</span>
<span class="nc bnc" id="L192" title="All 4 branches missed.">        if (wait != null &amp;&amp; wait.trim().length() &gt; 0) {</span>
<span class="nc" id="L193">            System.setProperty(Constants.SHUTDOWN_WAIT_KEY, wait.trim());</span>
        } else {
<span class="nc" id="L195">            wait = ConfigUtils.getProperty(Constants.SHUTDOWN_WAIT_SECONDS_KEY);</span>
<span class="nc bnc" id="L196" title="All 4 branches missed.">            if (wait != null &amp;&amp; wait.trim().length() &gt; 0) {</span>
<span class="nc" id="L197">                System.setProperty(Constants.SHUTDOWN_WAIT_SECONDS_KEY, wait.trim());</span>
            }
        }
<span class="nc" id="L200">    }</span>

    protected void checkMonitor() {
<span class="nc" id="L203">        createMonitorIfAbsent();</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">        if (!monitor.isValid()) {</span>
<span class="nc" id="L205">            logger.info(&quot;There's no valid monitor config found, if you want to open monitor statistics for Dubbo, &quot; +</span>
                    &quot;please make sure your monitor is configured properly.&quot;);
        }
<span class="nc" id="L208">    }</span>

    private void createMonitorIfAbsent() {
<span class="nc bnc" id="L211" title="All 2 branches missed.">        if (this.monitor != null) {</span>
<span class="nc" id="L212">            return;</span>
        }
<span class="nc" id="L214">        ConfigManager configManager = ConfigManager.getInstance();</span>
<span class="nc" id="L215">        setMonitor(</span>
                configManager
<span class="nc" id="L217">                        .getMonitor()</span>
<span class="nc" id="L218">                        .orElseGet(() -&gt; {</span>
<span class="nc" id="L219">                            MonitorConfig monitorConfig = new MonitorConfig();</span>
<span class="nc" id="L220">                            monitorConfig.refresh();</span>
<span class="nc" id="L221">                            return monitorConfig;</span>
                        })
        );
<span class="nc" id="L224">    }</span>

    protected void checkMetadataReport() {
        // TODO get from ConfigManager first, only create if absent.
<span class="nc bnc" id="L228" title="All 2 branches missed.">        if (metadataReportConfig == null) {</span>
<span class="nc" id="L229">            setMetadataReportConfig(new MetadataReportConfig());</span>
        }
<span class="nc" id="L231">        metadataReportConfig.refresh();</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">        if (!metadataReportConfig.isValid()) {</span>
<span class="nc" id="L233">            logger.warn(&quot;There's no valid metadata config found, if you are using the simplified mode of registry url, &quot; +</span>
                    &quot;please make sure you have a metadata address configured properly.&quot;);
        }
<span class="nc" id="L236">    }</span>


    void startConfigCenter() {
<span class="nc bnc" id="L240" title="All 2 branches missed.">        if (configCenter == null) {</span>
<span class="nc" id="L241">            ConfigManager.getInstance().getConfigCenter().ifPresent(cc -&gt; this.configCenter = cc);</span>
        }

<span class="nc bnc" id="L244" title="All 2 branches missed.">        if (this.configCenter != null) {</span>
            // TODO there may have duplicate refresh
<span class="nc" id="L246">            this.configCenter.refresh();</span>
<span class="nc" id="L247">            prepareEnvironment();</span>
        }
<span class="nc" id="L249">        ConfigManager.getInstance().refreshAll();</span>
<span class="nc" id="L250">    }</span>

    private void prepareEnvironment() {
<span class="nc bnc" id="L253" title="All 2 branches missed.">        if (configCenter.isValid()) {</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">            if (!configCenter.checkOrUpdateInited()) {</span>
<span class="nc" id="L255">                return;</span>
            }
<span class="nc" id="L257">            DynamicConfiguration dynamicConfiguration = getDynamicConfiguration(configCenter.toUrl());</span>
<span class="nc" id="L258">            String configContent = dynamicConfiguration.getConfig(configCenter.getConfigFile(), configCenter.getGroup());</span>

<span class="nc bnc" id="L260" title="All 2 branches missed.">            String appGroup = application != null ? application.getName() : null;</span>
<span class="nc" id="L261">            String appConfigContent = null;</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">            if (StringUtils.isNotEmpty(appGroup)) {</span>
<span class="nc" id="L263">                appConfigContent = dynamicConfiguration.getConfig</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">                        (StringUtils.isNotEmpty(configCenter.getAppConfigFile()) ? configCenter.getAppConfigFile() : configCenter.getConfigFile(),</span>
                         appGroup
                        );
            }
            try {
<span class="nc" id="L269">                Environment.getInstance().setConfigCenterFirst(configCenter.isHighestPriority());</span>
<span class="nc" id="L270">                Environment.getInstance().updateExternalConfigurationMap(parseProperties(configContent));</span>
<span class="nc" id="L271">                Environment.getInstance().updateAppExternalConfigurationMap(parseProperties(appConfigContent));</span>
<span class="nc" id="L272">            } catch (IOException e) {</span>
<span class="nc" id="L273">                throw new IllegalStateException(&quot;Failed to parse configurations from Config Center.&quot;, e);</span>
<span class="nc" id="L274">            }</span>
        }
<span class="nc" id="L276">    }</span>

    private DynamicConfiguration getDynamicConfiguration(URL url) {
<span class="nc" id="L279">        DynamicConfigurationFactory factories = ExtensionLoader</span>
<span class="nc" id="L280">                .getExtensionLoader(DynamicConfigurationFactory.class)</span>
<span class="nc" id="L281">                .getExtension(url.getProtocol());</span>
<span class="nc" id="L282">        DynamicConfiguration configuration = factories.getDynamicConfiguration(url);</span>
<span class="nc" id="L283">        Environment.getInstance().setDynamicConfiguration(configuration);</span>
<span class="nc" id="L284">        return configuration;</span>
    }

    /**
     *
     * Load the registry and conversion it to {@link URL}, the priority order is: system property &gt; dubbo registry config
     *
     * @param provider whether it is the provider side
     * @return
     */
    protected List&lt;URL&gt; loadRegistries(boolean provider) {
        // check &amp;&amp; override if necessary
<span class="nc" id="L296">        List&lt;URL&gt; registryList = new ArrayList&lt;URL&gt;();</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">        if (CollectionUtils.isNotEmpty(registries)) {</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">            for (RegistryConfig config : registries) {</span>
<span class="nc" id="L299">                String address = config.getAddress();</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">                if (StringUtils.isEmpty(address)) {</span>
<span class="nc" id="L301">                    address = Constants.ANYHOST_VALUE;</span>
                }
<span class="nc bnc" id="L303" title="All 2 branches missed.">                if (!RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) {</span>
<span class="nc" id="L304">                    Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</span>
<span class="nc" id="L305">                    appendParameters(map, application);</span>
<span class="nc" id="L306">                    appendParameters(map, config);</span>
<span class="nc" id="L307">                    map.put(Constants.PATH_KEY, RegistryService.class.getName());</span>
<span class="nc" id="L308">                    appendRuntimeParameters(map);</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">                    if (!map.containsKey(Constants.PROTOCOL_KEY)) {</span>
<span class="nc" id="L310">                        map.put(Constants.PROTOCOL_KEY, Constants.DUBBO_PROTOCOL);</span>
                    }
<span class="nc" id="L312">                    List&lt;URL&gt; urls = UrlUtils.parseURLs(address, map);</span>

<span class="nc bnc" id="L314" title="All 2 branches missed.">                    for (URL url : urls) {</span>
<span class="nc" id="L315">                        url = URLBuilder.from(url)</span>
<span class="nc" id="L316">                                .addParameter(Constants.REGISTRY_KEY, url.getProtocol())</span>
<span class="nc" id="L317">                                .setProtocol(Constants.REGISTRY_PROTOCOL)</span>
<span class="nc" id="L318">                                .build();</span>
<span class="nc bnc" id="L319" title="All 6 branches missed.">                        if ((provider &amp;&amp; url.getParameter(Constants.REGISTER_KEY, true))</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">                                || (!provider &amp;&amp; url.getParameter(Constants.SUBSCRIBE_KEY, true))) {</span>
<span class="nc" id="L321">                            registryList.add(url);</span>
                        }
<span class="nc" id="L323">                    }</span>
                }
<span class="nc" id="L325">            }</span>
        }
<span class="nc" id="L327">        return registryList;</span>
    }

    /**
     *
     * Load the monitor config from the system properties and conversation it to {@link URL}
     *
     * @param registryURL
     * @return
     */
    protected URL loadMonitor(URL registryURL) {
<span class="nc" id="L338">        checkMonitor();</span>
<span class="nc" id="L339">        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</span>
<span class="nc" id="L340">        map.put(Constants.INTERFACE_KEY, MonitorService.class.getName());</span>
<span class="nc" id="L341">        appendRuntimeParameters(map);</span>
        //set ip
<span class="nc" id="L343">        String hostToRegistry = ConfigUtils.getSystemProperty(Constants.DUBBO_IP_TO_REGISTRY);</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">        if (StringUtils.isEmpty(hostToRegistry)) {</span>
<span class="nc" id="L345">            hostToRegistry = NetUtils.getLocalHost();</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">        } else if (NetUtils.isInvalidLocalHost(hostToRegistry)) {</span>
<span class="nc" id="L347">            throw new IllegalArgumentException(&quot;Specified invalid registry ip from property:&quot; +</span>
                    Constants.DUBBO_IP_TO_REGISTRY + &quot;, value:&quot; + hostToRegistry);
        }
<span class="nc" id="L350">        map.put(Constants.REGISTER_IP_KEY, hostToRegistry);</span>
<span class="nc" id="L351">        appendParameters(map, monitor);</span>
<span class="nc" id="L352">        appendParameters(map, application);</span>
<span class="nc" id="L353">        String address = monitor.getAddress();</span>
<span class="nc" id="L354">        String sysaddress = System.getProperty(&quot;dubbo.monitor.address&quot;);</span>
<span class="nc bnc" id="L355" title="All 4 branches missed.">        if (sysaddress != null &amp;&amp; sysaddress.length() &gt; 0) {</span>
<span class="nc" id="L356">            address = sysaddress;</span>
        }
<span class="nc bnc" id="L358" title="All 2 branches missed.">        if (ConfigUtils.isNotEmpty(address)) {</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">            if (!map.containsKey(Constants.PROTOCOL_KEY)) {</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">                if (getExtensionLoader(MonitorFactory.class).hasExtension(Constants.LOGSTAT_PROTOCOL)) {</span>
<span class="nc" id="L361">                    map.put(Constants.PROTOCOL_KEY, Constants.LOGSTAT_PROTOCOL);</span>
                } else {
<span class="nc" id="L363">                    map.put(Constants.PROTOCOL_KEY, Constants.DUBBO_PROTOCOL);</span>
                }
            }
<span class="nc" id="L366">            return UrlUtils.parseURL(address, map);</span>
<span class="nc bnc" id="L367" title="All 4 branches missed.">        } else if (Constants.REGISTRY_PROTOCOL.equals(monitor.getProtocol()) &amp;&amp; registryURL != null) {</span>
<span class="nc" id="L368">            return URLBuilder.from(registryURL)</span>
<span class="nc" id="L369">                    .setProtocol(Constants.DUBBO_PROTOCOL)</span>
<span class="nc" id="L370">                    .addParameter(Constants.PROTOCOL_KEY, Constants.REGISTRY_PROTOCOL)</span>
<span class="nc" id="L371">                    .addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map))</span>
<span class="nc" id="L372">                    .build();</span>
        }
<span class="nc" id="L374">        return null;</span>
    }

    static void appendRuntimeParameters(Map&lt;String, String&gt; map) {
<span class="nc" id="L378">        map.put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion());</span>
<span class="nc" id="L379">        map.put(Constants.RELEASE_KEY, Version.getVersion());</span>
<span class="nc" id="L380">        map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">        if (ConfigUtils.getPid() &gt; 0) {</span>
<span class="nc" id="L382">            map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span>
        }
<span class="nc" id="L384">    }</span>

    private URL loadMetadataReporterURL() {
<span class="nc" id="L387">        String address = metadataReportConfig.getAddress();</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">        if (StringUtils.isEmpty(address)) {</span>
<span class="nc" id="L389">            return null;</span>
        }
<span class="nc" id="L391">        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</span>
<span class="nc" id="L392">        appendParameters(map, metadataReportConfig);</span>
<span class="nc" id="L393">        return UrlUtils.parseURL(address, map);</span>
    }

    protected MetadataReportService getMetadataReportService() {

<span class="nc bnc" id="L398" title="All 4 branches missed.">        if (metadataReportConfig == null || !metadataReportConfig.isValid()) {</span>
<span class="nc" id="L399">            return null;</span>
        }
<span class="nc" id="L401">        return MetadataReportService.instance(this::loadMetadataReporterURL);</span>
    }

    /**
     * Check whether the remote service interface and the methods meet with Dubbo's requirements.it mainly check, if the
     * methods configured in the configuration file are included in the interface of remote service
     *
     * @param interfaceClass the interface of remote service
     * @param methods the methods configured
     */
    protected void checkInterfaceAndMethods(Class&lt;?&gt; interfaceClass, List&lt;MethodConfig&gt; methods) {
        // interface cannot be null
<span class="nc" id="L413">        Assert.notNull(interfaceClass, new IllegalStateException(&quot;interface not allow null!&quot;));</span>

        // to verify interfaceClass is an interface
<span class="nc bnc" id="L416" title="All 2 branches missed.">        if (!interfaceClass.isInterface()) {</span>
<span class="nc" id="L417">            throw new IllegalStateException(&quot;The interface class &quot; + interfaceClass + &quot; is not a interface!&quot;);</span>
        }
        // check if methods exist in the remote service interface
<span class="nc bnc" id="L420" title="All 2 branches missed.">        if (CollectionUtils.isNotEmpty(methods)) {</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">            for (MethodConfig methodBean : methods) {</span>
<span class="nc" id="L422">                methodBean.setService(interfaceClass.getName());</span>
<span class="nc" id="L423">                methodBean.setServiceId(this.getId());</span>
<span class="nc" id="L424">                methodBean.refresh();</span>
<span class="nc" id="L425">                String methodName = methodBean.getName();</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">                if (StringUtils.isEmpty(methodName)) {</span>
<span class="nc" id="L427">                    throw new IllegalStateException(&quot;&lt;dubbo:method&gt; name attribute is required! Please check: &quot; +</span>
<span class="nc" id="L428">                            &quot;&lt;dubbo:service interface=\&quot;&quot; + interfaceClass.getName() + &quot;\&quot; ... &gt;&quot; +</span>
                            &quot;&lt;dubbo:method name=\&quot;\&quot; ... /&gt;&lt;/&lt;dubbo:reference&gt;&quot;);
                }

<span class="nc" id="L432">                boolean hasMethod = Arrays.stream(interfaceClass.getMethods()).anyMatch(method -&gt; method.getName().equals(methodName));</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">                if (!hasMethod) {</span>
<span class="nc" id="L434">                    throw new IllegalStateException(&quot;The interface &quot; + interfaceClass.getName()</span>
                            + &quot; not found method &quot; + methodName);
                }
<span class="nc" id="L437">            }</span>
        }
<span class="nc" id="L439">    }</span>

    /**
     * Legitimacy check and setup of local simulated operations. The operations can be a string with Simple operation or
     * a classname whose {@link Class} implements a particular function
     *
     * @param interfaceClass for provider side, it is the {@link Class} of the service that will be exported; for consumer
     *                       side, it is the {@link Class} of the remote service interface that will be referenced
     */
    void checkMock(Class&lt;?&gt; interfaceClass) {
<span class="nc bnc" id="L449" title="All 2 branches missed.">        if (ConfigUtils.isEmpty(mock)) {</span>
<span class="nc" id="L450">            return;</span>
        }

<span class="nc" id="L453">        String normalizedMock = MockInvoker.normalizeMock(mock);</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">        if (normalizedMock.startsWith(Constants.RETURN_PREFIX)) {</span>
<span class="nc" id="L455">            normalizedMock = normalizedMock.substring(Constants.RETURN_PREFIX.length()).trim();</span>
            try {
                //Check whether the mock value is legal, if it is illegal, throw exception
<span class="nc" id="L458">                MockInvoker.parseMockValue(normalizedMock);</span>
<span class="nc" id="L459">            } catch (Exception e) {</span>
<span class="nc" id="L460">                throw new IllegalStateException(&quot;Illegal mock return in &lt;dubbo:service/reference ... &quot; +</span>
                        &quot;mock=\&quot;&quot; + mock + &quot;\&quot; /&gt;&quot;);
<span class="nc" id="L462">            }</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">        } else if (normalizedMock.startsWith(Constants.THROW_PREFIX)) {</span>
<span class="nc" id="L464">            normalizedMock = normalizedMock.substring(Constants.THROW_PREFIX.length()).trim();</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">            if (ConfigUtils.isNotEmpty(normalizedMock)) {</span>
                try {
                    //Check whether the mock value is legal
<span class="nc" id="L468">                    MockInvoker.getThrowable(normalizedMock);</span>
<span class="nc" id="L469">                } catch (Exception e) {</span>
<span class="nc" id="L470">                    throw new IllegalStateException(&quot;Illegal mock throw in &lt;dubbo:service/reference ... &quot; +</span>
                            &quot;mock=\&quot;&quot; + mock + &quot;\&quot; /&gt;&quot;);
<span class="nc" id="L472">                }</span>
            }
        } else {
            //Check whether the mock class is a implementation of the interfaceClass, and if it has a default constructor
<span class="nc" id="L476">            MockInvoker.getMockObject(normalizedMock, interfaceClass);</span>
        }
<span class="nc" id="L478">    }</span>

    /**
     * Legitimacy check of stub, note that: the local will deprecated, and replace with &lt;code&gt;stub&lt;/code&gt;
     *
     * @param interfaceClass for provider side, it is the {@link Class} of the service that will be exported; for consumer
     *                       side, it is the {@link Class} of the remote service interface
     */
    void checkStubAndLocal(Class&lt;?&gt; interfaceClass) {
<span class="nc bnc" id="L487" title="All 2 branches missed.">        if (ConfigUtils.isNotEmpty(local)) {</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">            Class&lt;?&gt; localClass = ConfigUtils.isDefault(local) ?</span>
<span class="nc" id="L489">                    ReflectUtils.forName(interfaceClass.getName() + &quot;Local&quot;) : ReflectUtils.forName(local);</span>
<span class="nc" id="L490">            verify(interfaceClass, localClass);</span>
        }
<span class="nc bnc" id="L492" title="All 2 branches missed.">        if (ConfigUtils.isNotEmpty(stub)) {</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">            Class&lt;?&gt; localClass = ConfigUtils.isDefault(stub) ?</span>
<span class="nc" id="L494">                    ReflectUtils.forName(interfaceClass.getName() + &quot;Stub&quot;) : ReflectUtils.forName(stub);</span>
<span class="nc" id="L495">            verify(interfaceClass, localClass);</span>
        }
<span class="nc" id="L497">    }</span>

    private void verify(Class&lt;?&gt; interfaceClass, Class&lt;?&gt; localClass) {
<span class="nc bnc" id="L500" title="All 2 branches missed.">        if (!interfaceClass.isAssignableFrom(localClass)) {</span>
<span class="nc" id="L501">            throw new IllegalStateException(&quot;The local implementation class &quot; + localClass.getName() +</span>
<span class="nc" id="L502">                    &quot; not implement interface &quot; + interfaceClass.getName());</span>
        }

        try {
            //Check if the localClass a constructor with parameter who's type is interfaceClass
<span class="nc" id="L507">            ReflectUtils.findConstructor(localClass, interfaceClass);</span>
<span class="nc" id="L508">        } catch (NoSuchMethodException e) {</span>
<span class="nc" id="L509">            throw new IllegalStateException(&quot;No such constructor \&quot;public &quot; + localClass.getSimpleName() +</span>
<span class="nc" id="L510">                    &quot;(&quot; + interfaceClass.getName() + &quot;)\&quot; in local implementation class &quot; + localClass.getName());</span>
<span class="nc" id="L511">        }</span>
<span class="nc" id="L512">    }</span>

    private void convertRegistryIdsToRegistries() {
<span class="nc bnc" id="L515" title="All 4 branches missed.">        if (StringUtils.isEmpty(registryIds) &amp;&amp; CollectionUtils.isEmpty(registries)) {</span>
<span class="nc" id="L516">            Set&lt;String&gt; configedRegistries = new HashSet&lt;&gt;();</span>
<span class="nc" id="L517">            configedRegistries.addAll(getSubProperties(Environment.getInstance().getExternalConfigurationMap(),</span>
                    Constants.REGISTRIES_SUFFIX));
<span class="nc" id="L519">            configedRegistries.addAll(getSubProperties(Environment.getInstance().getAppExternalConfigurationMap(),</span>
                    Constants.REGISTRIES_SUFFIX));

<span class="nc" id="L522">            registryIds = String.join(Constants.COMMA_SEPARATOR, configedRegistries);</span>
        }

<span class="nc bnc" id="L525" title="All 2 branches missed.">        if (StringUtils.isEmpty(registryIds)) {</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">            if (CollectionUtils.isEmpty(registries)) {</span>
<span class="nc" id="L527">                setRegistries(</span>
<span class="nc" id="L528">                        ConfigManager.getInstance().getDefaultRegistries()</span>
<span class="nc" id="L529">                        .filter(CollectionUtils::isNotEmpty)</span>
<span class="nc" id="L530">                        .orElseGet(() -&gt; {</span>
<span class="nc" id="L531">                            RegistryConfig registryConfig = new RegistryConfig();</span>
<span class="nc" id="L532">                            registryConfig.refresh();</span>
<span class="nc" id="L533">                            return Arrays.asList(registryConfig);</span>
                        })
                );
            }
        } else {
<span class="nc" id="L538">            String[] ids = Constants.COMMA_SPLIT_PATTERN.split(registryIds);</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">            List&lt;RegistryConfig&gt; tmpRegistries = CollectionUtils.isNotEmpty(registries) ? registries : new ArrayList&lt;&gt;();</span>
<span class="nc" id="L540">            Arrays.stream(ids).forEach(id -&gt; {</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">                if (tmpRegistries.stream().noneMatch(reg -&gt; reg.getId().equals(id))) {</span>
<span class="nc" id="L542">                    tmpRegistries.add(ConfigManager.getInstance().getRegistry(id).orElseGet(() -&gt; {</span>
<span class="nc" id="L543">                        RegistryConfig registryConfig = new RegistryConfig();</span>
<span class="nc" id="L544">                        registryConfig.setId(id);</span>
<span class="nc" id="L545">                        registryConfig.refresh();</span>
<span class="nc" id="L546">                        return registryConfig;</span>
                    }));
                }
<span class="nc" id="L549">            });</span>

<span class="nc bnc" id="L551" title="All 2 branches missed.">            if (tmpRegistries.size() &gt; ids.length) {</span>
<span class="nc" id="L552">                throw new IllegalStateException(&quot;Too much registries found, the registries assigned to this service &quot; +</span>
<span class="nc" id="L553">                        &quot;are :&quot; + registryIds + &quot;, but got &quot; + tmpRegistries.size() + &quot; registries!&quot;);</span>
            }

<span class="nc" id="L556">            setRegistries(tmpRegistries);</span>
        }

<span class="nc" id="L559">    }</span>

    private void loadRegistriesFromBackwardConfig() {
        // for backward compatibility
        // -Ddubbo.registry.address is now deprecated.
<span class="nc bnc" id="L564" title="All 4 branches missed.">        if (registries == null || registries.isEmpty()) {</span>
<span class="nc" id="L565">            String address = ConfigUtils.getProperty(&quot;dubbo.registry.address&quot;);</span>
<span class="nc bnc" id="L566" title="All 4 branches missed.">            if (address != null &amp;&amp; address.length() &gt; 0) {</span>
<span class="nc" id="L567">                List&lt;RegistryConfig&gt; tmpRegistries = new ArrayList&lt;RegistryConfig&gt;();</span>
<span class="nc" id="L568">                String[] as = address.split(&quot;\\s*[|]+\\s*&quot;);</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">                for (String a : as) {</span>
<span class="nc" id="L570">                    RegistryConfig registryConfig = new RegistryConfig();</span>
<span class="nc" id="L571">                    registryConfig.setAddress(a);</span>
<span class="nc" id="L572">                    registryConfig.refresh();</span>
<span class="nc" id="L573">                    tmpRegistries.add(registryConfig);</span>
                }
<span class="nc" id="L575">                setRegistries(tmpRegistries);</span>
            }
        }
<span class="nc" id="L578">    }</span>

    /**
     * For compatibility purpose, use registry as the default config center if the registry protocol is zookeeper and
     * there's no config center specified explicitly.
     */
    private void useRegistryForConfigIfNecessary() {
<span class="nc" id="L585">        registries.stream().filter(RegistryConfig::isZookeeperProtocol).findFirst().ifPresent(rc -&gt; {</span>
            // we use the loading status of DynamicConfiguration to decide whether ConfigCenter has been initiated.
<span class="nc" id="L587">            Environment.getInstance().getDynamicConfiguration().orElseGet(() -&gt; {</span>
<span class="nc" id="L588">                ConfigManager configManager = ConfigManager.getInstance();</span>
<span class="nc" id="L589">                ConfigCenterConfig cc = configManager.getConfigCenter().orElse(new ConfigCenterConfig());</span>
<span class="nc" id="L590">                cc.setProtocol(rc.getProtocol());</span>
<span class="nc" id="L591">                cc.setAddress(rc.getAddress());</span>
<span class="nc" id="L592">                cc.setHighestPriority(false);</span>
<span class="nc" id="L593">                setConfigCenter(cc);</span>
<span class="nc" id="L594">                startConfigCenter();</span>
<span class="nc" id="L595">                return null;</span>
            });
<span class="nc" id="L597">        });</span>
<span class="nc" id="L598">    }</span>

    /**
     * @return local
     * @deprecated Replace to &lt;code&gt;getStub()&lt;/code&gt;
     */
    @Deprecated
    public String getLocal() {
<span class="nc" id="L606">        return local;</span>
    }

    /**
     * @param local
     * @deprecated Replace to &lt;code&gt;setStub(Boolean)&lt;/code&gt;
     */
    @Deprecated
    public void setLocal(Boolean local) {
<span class="nc bnc" id="L615" title="All 2 branches missed.">        if (local == null) {</span>
<span class="nc" id="L616">            setLocal((String) null);</span>
        } else {
<span class="nc" id="L618">            setLocal(local.toString());</span>
        }
<span class="nc" id="L620">    }</span>

    /**
     * @param local
     * @deprecated Replace to &lt;code&gt;setStub(String)&lt;/code&gt;
     */
    @Deprecated
    public void setLocal(String local) {
<span class="nc" id="L628">        checkName(Constants.LOCAL_KEY, local);</span>
<span class="nc" id="L629">        this.local = local;</span>
<span class="nc" id="L630">    }</span>

    public String getStub() {
<span class="nc" id="L633">        return stub;</span>
    }

    public void setStub(Boolean stub) {
<span class="nc bnc" id="L637" title="All 2 branches missed.">        if (stub == null) {</span>
<span class="nc" id="L638">            setStub((String) null);</span>
        } else {
<span class="nc" id="L640">            setStub(stub.toString());</span>
        }
<span class="nc" id="L642">    }</span>

    public void setStub(String stub) {
<span class="nc" id="L645">        checkName(&quot;stub&quot;, stub);</span>
<span class="nc" id="L646">        this.stub = stub;</span>
<span class="nc" id="L647">    }</span>

    public String getCluster() {
<span class="nc" id="L650">        return cluster;</span>
    }

    public void setCluster(String cluster) {
<span class="nc" id="L654">        checkExtension(Cluster.class, Constants.CLUSTER_KEY, cluster);</span>
<span class="nc" id="L655">        this.cluster = cluster;</span>
<span class="nc" id="L656">    }</span>

    public String getProxy() {
<span class="nc" id="L659">        return proxy;</span>
    }

    public void setProxy(String proxy) {
<span class="nc" id="L663">        checkExtension(ProxyFactory.class, Constants.PROXY_KEY, proxy);</span>
<span class="nc" id="L664">        this.proxy = proxy;</span>
<span class="nc" id="L665">    }</span>

    public Integer getConnections() {
<span class="nc" id="L668">        return connections;</span>
    }

    public void setConnections(Integer connections) {
<span class="nc" id="L672">        this.connections = connections;</span>
<span class="nc" id="L673">    }</span>

    @Parameter(key = Constants.REFERENCE_FILTER_KEY, append = true)
    public String getFilter() {
<span class="nc" id="L677">        return filter;</span>
    }

    public void setFilter(String filter) {
<span class="nc" id="L681">        checkMultiExtension(Filter.class, Constants.FILE_KEY, filter);</span>
<span class="nc" id="L682">        this.filter = filter;</span>
<span class="nc" id="L683">    }</span>

    @Parameter(key = Constants.INVOKER_LISTENER_KEY, append = true)
    public String getListener() {
<span class="nc" id="L687">        return listener;</span>
    }

    public void setListener(String listener) {
<span class="nc" id="L691">        checkMultiExtension(InvokerListener.class, Constants.LISTENER_KEY, listener);</span>
<span class="nc" id="L692">        this.listener = listener;</span>
<span class="nc" id="L693">    }</span>

    public String getLayer() {
<span class="nc" id="L696">        return layer;</span>
    }

    public void setLayer(String layer) {
<span class="nc" id="L700">        checkNameHasSymbol(Constants.LAYER_KEY, layer);</span>
<span class="nc" id="L701">        this.layer = layer;</span>
<span class="nc" id="L702">    }</span>

    public ApplicationConfig getApplication() {
<span class="nc" id="L705">        return application;</span>
    }

    public void setApplication(ApplicationConfig application) {
<span class="nc" id="L709">        ConfigManager.getInstance().setApplication(application);</span>
<span class="nc" id="L710">        this.application = application;</span>
<span class="nc" id="L711">    }</span>

    private void createApplicationIfAbsent() {
<span class="nc bnc" id="L714" title="All 2 branches missed.">        if (this.application != null) {</span>
<span class="nc" id="L715">            return;</span>
        }
<span class="nc" id="L717">        ConfigManager configManager = ConfigManager.getInstance();</span>
<span class="nc" id="L718">        setApplication(</span>
                configManager
<span class="nc" id="L720">                        .getApplication()</span>
<span class="nc" id="L721">                        .orElseGet(() -&gt; {</span>
<span class="nc" id="L722">                            ApplicationConfig applicationConfig = new ApplicationConfig();</span>
<span class="nc" id="L723">                            applicationConfig.refresh();</span>
<span class="nc" id="L724">                            return applicationConfig;</span>
                        })
        );
<span class="nc" id="L727">    }</span>

    public ModuleConfig getModule() {
<span class="nc" id="L730">        return module;</span>
    }

    public void setModule(ModuleConfig module) {
<span class="nc" id="L734">        ConfigManager.getInstance().setModule(module);</span>
<span class="nc" id="L735">        this.module = module;</span>
<span class="nc" id="L736">    }</span>

    public RegistryConfig getRegistry() {
<span class="nc bnc" id="L739" title="All 2 branches missed.">        return CollectionUtils.isEmpty(registries) ? null : registries.get(0);</span>
    }

    public void setRegistry(RegistryConfig registry) {
<span class="nc" id="L743">        List&lt;RegistryConfig&gt; registries = new ArrayList&lt;RegistryConfig&gt;(1);</span>
<span class="nc" id="L744">        registries.add(registry);</span>
<span class="nc" id="L745">        setRegistries(registries);</span>
<span class="nc" id="L746">    }</span>

    public List&lt;RegistryConfig&gt; getRegistries() {
<span class="nc" id="L749">        return registries;</span>
    }

    @SuppressWarnings({&quot;unchecked&quot;})
    public void setRegistries(List&lt;? extends RegistryConfig&gt; registries) {
<span class="nc" id="L754">        ConfigManager.getInstance().addRegistries((List&lt;RegistryConfig&gt;) registries);</span>
<span class="nc" id="L755">        this.registries = (List&lt;RegistryConfig&gt;) registries;</span>
<span class="nc" id="L756">    }</span>

    @Parameter(excluded = true)
    public String getRegistryIds() {
<span class="nc" id="L760">        return registryIds;</span>
    }

    public void setRegistryIds(String registryIds) {
<span class="nc" id="L764">        this.registryIds = registryIds;</span>
<span class="nc" id="L765">    }</span>

    public MonitorConfig getMonitor() {
<span class="nc" id="L768">        return monitor;</span>
    }

    public void setMonitor(String monitor) {
<span class="nc" id="L772">        setMonitor(new MonitorConfig(monitor));</span>
<span class="nc" id="L773">    }</span>

    public void setMonitor(MonitorConfig monitor) {
<span class="nc" id="L776">        ConfigManager.getInstance().setMonitor(monitor);</span>
<span class="nc" id="L777">        this.monitor = monitor;</span>
<span class="nc" id="L778">    }</span>

    public String getOwner() {
<span class="nc" id="L781">        return owner;</span>
    }

    public void setOwner(String owner) {
<span class="nc" id="L785">        checkMultiName(&quot;owner&quot;, owner);</span>
<span class="nc" id="L786">        this.owner = owner;</span>
<span class="nc" id="L787">    }</span>

    public ConfigCenterConfig getConfigCenter() {
<span class="nc" id="L790">        return configCenter;</span>
    }

    public void setConfigCenter(ConfigCenterConfig configCenter) {
<span class="nc" id="L794">        ConfigManager.getInstance().setConfigCenter(configCenter);</span>
<span class="nc" id="L795">        this.configCenter = configCenter;</span>
<span class="nc" id="L796">    }</span>

    public Integer getCallbacks() {
<span class="nc" id="L799">        return callbacks;</span>
    }

    public void setCallbacks(Integer callbacks) {
<span class="nc" id="L803">        this.callbacks = callbacks;</span>
<span class="nc" id="L804">    }</span>

    public String getOnconnect() {
<span class="nc" id="L807">        return onconnect;</span>
    }

    public void setOnconnect(String onconnect) {
<span class="nc" id="L811">        this.onconnect = onconnect;</span>
<span class="nc" id="L812">    }</span>

    public String getOndisconnect() {
<span class="nc" id="L815">        return ondisconnect;</span>
    }

    public void setOndisconnect(String ondisconnect) {
<span class="nc" id="L819">        this.ondisconnect = ondisconnect;</span>
<span class="nc" id="L820">    }</span>

    public String getScope() {
<span class="nc" id="L823">        return scope;</span>
    }

    public void setScope(String scope) {
<span class="nc" id="L827">        this.scope = scope;</span>
<span class="nc" id="L828">    }</span>

    public MetadataReportConfig getMetadataReportConfig() {
<span class="nc" id="L831">        return metadataReportConfig;</span>
    }

    public void setMetadataReportConfig(MetadataReportConfig metadataReportConfig) {
<span class="nc" id="L835">        this.metadataReportConfig = metadataReportConfig;</span>
<span class="nc" id="L836">    }</span>

    public MetricsConfig getMetrics() {
<span class="nc" id="L839">        return metrics;</span>
    }

    public void setMetrics(MetricsConfig metrics) {
<span class="nc" id="L843">        this.metrics = metrics;</span>
<span class="nc" id="L844">    }</span>

    @Parameter(key = Constants.TAG_KEY, useKeyAsProperty = false)
    public String getTag() {
<span class="nc" id="L848">        return tag;</span>
    }

    public void setTag(String tag) {
<span class="nc" id="L852">        this.tag = tag;</span>
<span class="nc" id="L853">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>